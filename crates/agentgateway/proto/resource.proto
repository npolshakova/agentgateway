syntax = "proto3";

package agentgateway.dev.resource;

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

option go_package = "github.com/agentgateway/agentgateway/go/api;api";

message Resource {
  oneof kind {
    Bind bind = 1;
    Listener listener = 2;
    Route route = 3;
    Backend backend = 4;
    Policy policy = 5;
    TCPRoute tcp_route = 6;
  }
}

message Bind {
  string key = 1;
  uint32 port = 2;
}

message Listener {
  // Unique key
  string key = 1;
  // User facing name; may not be unique
  string name = 2;
  string bind_key = 3;
  // User facing Gateway name
  string gateway_name = 4;
  string hostname = 5;
  Protocol protocol = 6;
  TLSConfig tls = 7;
}

message TLSConfig {
  bytes cert = 1;
  bytes private_key = 2;
}

enum Protocol {
  UNKNOWN = 0;
  HTTP = 1;
  HTTPS = 2;
  TLS = 3;
  TCP = 4;
  HBONE = 5;
}
message Route {
  // Unique key
  string key = 1;
  string listener_key = 2;
  // User facing rule name. May not be unique.
  string rule_name = 3;
  // User facing route name May not be unique.
  string route_name = 4;
  repeated string hostnames = 5;
  repeated RouteMatch matches = 6;
  repeated RouteFilter filters = 7;
  repeated RouteBackend backends = 8;
  TrafficPolicy traffic_policy = 9;
  repeated TrafficPolicySpec inline_policies = 10;
}

message TCPRoute {
  // Unique key
  string key = 1;
  string listener_key = 2;
  // User facing rule name. May not be unique.
  string rule_name = 3;
  // User facing route name May not be unique.
  string route_name = 4;
  repeated string hostnames = 5;
  repeated RouteBackend backends = 6;
}

message TrafficPolicy {
  google.protobuf.Duration backend_request_timeout = 1;
  google.protobuf.Duration request_timeout = 2;
  Retry retry = 3;
}

message Retry {
  repeated int32 retry_status_codes = 1;
  int32 attempts = 2;
  google.protobuf.Duration backoff = 3;
}

message BackendAuthPolicy {
  oneof kind {
    Passthrough passthrough = 1;
    Key key = 2;
    Gcp gcp = 3;
    Aws aws = 4;
    Azure azure = 5;
  }
}

// No fields needed for passthrough authentication.
message Passthrough {}

// Contains a secret for authentication, e.g. an API key.
message Key {
  string secret = 1;
}

// GCP-specific backend authentication.
message Gcp {}

// AWS-specific backend authentication.
message Aws {
  oneof kind {
    AwsExplicitConfig explicit_config = 1;
    AwsImplicit implicit = 2;
  }
}

// Azure-specific backend authentication.
message Azure {
  oneof kind {
    AzureExplicitConfig explicit_config = 1;
    AzureDeveloperImplicit developer_implicit = 2;
  }
}

// Explicit AWS credentials configuration
message AwsExplicitConfig {
  // AWS Access Key ID for authentication
  string access_key_id = 1;
  // AWS Secret Access Key for authentication
  string secret_access_key = 2;
  // AWS Region (e.g., "us-west-2", "us-east-1")
  string region = 3;
  // Optional session token for temporary credentials
  optional string session_token = 4;
  // TODO: make service configurable
}

// Use implicit AWS authentication (environment variables, IAM roles, etc.)
message AwsImplicit {}

// Explicit Azure credentials configuration
message AzureExplicitConfig {
  oneof credential_source {
    AzureClientSecret client_secret = 1;
    AzureManagedIdentityCredential managed_identity_credential = 2;
    AzureWorkloadIdentityCredential workload_identity_credential = 3;
  }
}

// Azure Client Secret authentication method
message AzureClientSecret {
  // Azure tenant ID
  string tenant_id = 1;
  // Azure client ID (application ID)
  string client_id = 2;
  // Azure client secret
  string client_secret = 3;
}

// Azure Managed Identity authentication method
message AzureManagedIdentityCredential {
  message UserAssignedIdentity {
    oneof id {
      string client_id = 1;
      string object_id = 2;
      string resource_id = 3;
    }
  }
  // The UAMI to be used to authenticate. If not set, the system-assigned identity will be used.
  optional UserAssignedIdentity user_assigned_identity = 1;
}

// Azure Workload Identity authentication method
message AzureWorkloadIdentityCredential {}

// Use implicit Azure authentication for developer use-cases only
message AzureDeveloperImplicit {}

message RouteMatch {
  PathMatch path = 1;
  repeated HeaderMatch headers = 2;
  MethodMatch method = 3;
  repeated QueryMatch query_params = 4;
}

message PathMatch {
  oneof kind {
    string exact = 1;
    string path_prefix = 2;
    string regex = 3;
  }
}

message QueryMatch {
  string name = 1;
  oneof value {
    string exact = 2;
    string regex = 3;
  }
}

message MethodMatch {
  string exact = 1;
}

message HeaderMatch {
  string name = 1;

  oneof value {
    string exact = 2;
    string regex = 3;
  }
}

message RouteFilter {
  oneof kind {
    RequestMirror request_mirror = 1;
    RequestRedirect request_redirect = 2;
    UrlRewrite url_rewrite = 3;
    DirectResponse direct_response = 4;
  }
}

message CORS {
  bool allow_credentials = 1;
  repeated string allow_headers = 2;
  repeated string allow_methods = 3;
  repeated string allow_origins = 4;
  repeated string expose_headers = 5;
  // max_age is in seconds, use google.protobuf.Duration if available, otherwise uint64 for seconds
  google.protobuf.Duration max_age = 6;
}

message DirectResponse {
  uint32 status = 1;
  bytes body = 2;
}

message HeaderModifier {
  repeated Header add = 1;
  repeated Header set = 2;
  repeated string remove = 3;
}

message RequestMirror {
  BackendReference backend = 1;
  // 0-100
  double percentage = 2;
}

message RequestRedirect {
  string scheme = 1;
  string host = 2;
  oneof path {
    string full = 3;
    string prefix = 4;
  }
  uint32 port = 5;
  uint32 status = 6;
}

message UrlRewrite {
  string host = 1;
  oneof path {
    string full = 2;
    string prefix = 3;
  }
}

message Header {
  string name = 1;
  string value = 2;
}

message RouteBackend {
  BackendReference backend = 1;
  int32 weight = 2;
  repeated RouteFilter filters = 4;
}

message PolicyTarget {
  oneof kind {
    // Matches Listener.gateway_name
    string gateway = 1;
    // Matches Listener.name
    string listener = 2;
    // Match Route.route_name
    string route = 3;
    // Matches Route.rule_name
    string route_rule = 4;
    // For ServicePort: `service/{namespace}/{hostname}:{port}`
    // For Backend: `{ns}/{name}`
    string backend = 5;
    // namespace}/{hostname}
    string service = 6;
    // For Backend: `{ns}/{name}/{sub-backend}`
    string sub_backend = 7;
  }
}

message RBAC {
  repeated string allow = 1;
  repeated string deny = 2;
}

message BackendPolicySpec {
    message Ai {
    message Message {
      string role = 1;
      string content = 2;
    }

    message PromptEnrichment {
      repeated Message append = 1;
      repeated Message prepend = 2;
    }

    enum BuiltinRegexRule {
      BUILTIN_UNSPECIFIED = 0;
      SSN = 1;
      CREDIT_CARD = 2;
      PHONE_NUMBER = 3;
      EMAIL = 4;
    }

    message NamedRegex {
      string pattern = 1;
      string name = 2;
    }

    message RegexRule {
      oneof kind {
        BuiltinRegexRule builtin = 1;
        NamedRegex regex = 2;
      }
    }

    enum ActionKind {
      ACTION_UNSPECIFIED = 0;
      MASK = 1;
      REJECT = 2;
    }

    message Action {
      ActionKind kind = 1;
      // Only used when kind == REJECT
      RequestRejection reject_response = 2;
    }

    message RegexRules {
      Action action = 1;
      repeated RegexRule rules = 2;
    }

    message Webhook {
      string host = 1;
      uint32 port = 2;
      repeated HeaderMatch forward_header_matches = 3;
    }

    message Moderation {
      // Model to use. Defaults to `omni-moderation-latest`
      google.protobuf.StringValue model = 1;
      BackendAuthPolicy auth = 2;
    }

    // Response sent when rejecting a request
    message RequestRejection {
      bytes body = 1;
      uint32 status = 2;
    }

    // Configuration for guarding/processing LLM responses
    message ResponseGuard {
      RegexRules regex = 1;
      Webhook webhook = 2;
    }

    // Configuration for guarding/processing prompts
    message RequestGuard {
      // Response to send when request is rejected
      RequestRejection rejection = 1;
      RegexRules regex = 2;
      Webhook webhook = 3;
      Moderation openai_moderation = 4;
    }

    message PromptGuard {
      // Guards applied to client requests before they reach the LLM
      RequestGuard request = 1;
      // Guards applied to LLM responses before they reach the client
      ResponseGuard response = 2;
    }

    PromptGuard prompt_guard = 1;
    // Default JSON key-value pairs to add to the LLM request if the key is not set in the request.
    map<string, string> defaults = 2;
    // Override JSON key-value pairs to set in the LLM request regardless of whether they are set in the request.
    map<string, string> overrides = 3;
    PromptEnrichment prompts = 4;
    // Model aliases - map from alias name to actual model name
    map<string, string> model_aliases = 5;
  }
    message A2a {
  }
  message InferenceRouting {
    enum FailureMode {
      UNKNOWN = 0;
      FAIL_CLOSED = 1;
      FAIL_OPEN = 2;
    }
    BackendReference endpoint_picker = 1;
    FailureMode failure_mode = 2;
  }
    message BackendTLS {
    google.protobuf.BytesValue cert = 1;
    google.protobuf.BytesValue key = 2;
    // Root to verify. If not set, system certs will be used.
    // If no verification is desired, use 'insecure'
    google.protobuf.BytesValue root = 3;
    // Disable all verification
    google.protobuf.BoolValue insecure = 4;
    // If set, override the SNI explicitly. Otherwise, it is auto-derived.
    google.protobuf.StringValue hostname = 5;
  }

    oneof kind {
    A2a a2a = 1;
    InferenceRouting inference_routing = 2;
    BackendTLS backend_tls = 3;
    BackendAuthPolicy auth = 4;
    RBAC mcp_authorization = 5;
    Ai ai = 6;
  }
}

message FrontendPolicySpec {
  // TODO: support tracing, access logging, etc. here 
}

message TrafficPolicySpec {
  message RemoteRateLimit {
    string domain = 1;
    repeated Descriptor descriptors = 2;
    BackendReference target = 3;

    enum Type { REQUESTS = 0; TOKENS = 1; }
    message Descriptor {
      repeated Entry entries = 1;
      Type type = 2;
    }
    message Entry {
      string key = 1;
      string value = 2; // CEL expr
    }
  }
  message LocalRateLimit {
    enum Type {
      REQUEST = 0;
      TOKEN = 1;
    }
    uint64 max_tokens = 1;
    uint64 tokens_per_fill = 2;
    google.protobuf.Duration fill_interval = 3;
    Type type = 4;
  }

  message ExternalAuth {
    enum FailureMode {
      DENY = 0;
      ALLOW = 1;
      DENY_WITH_STATUS = 2;
    }
    message BodyOptions {
      uint32 max_request_bytes = 1;
      bool allow_partial_message = 2;
      bool pack_as_bytes = 3;
    }
    BackendReference target = 1;
    map<string, string> context = 2;
    FailureMode failure_mode = 3;
    repeated string include_request_headers = 4;
    BodyOptions include_request_body = 5;
    google.protobuf.Duration timeout = 6;
    google.protobuf.UInt32Value status_on_error = 7;
  }

  // JWT authentication configuration
  message JWT {
    // Validation mode for JWT authentication
    enum Mode {
      // Default mode - if a token exists, validate it
      OPTIONAL = 0;
      // A valid token must be present
      STRICT = 1;
      // Requests are never rejected (useful for claims in later steps)
      PERMISSIVE = 2;
    }

    // How the JWT validation should behave
    Mode mode = 1;

    // JWT issuer that must match the 'iss' claim
    string issuer = 2;

    // List of audiences - the 'aud' claim must be in this list
    repeated string audiences = 3;

    // JWKS configuration - where to get the keys for validation
    oneof jwks_source {
      // Inline JWKS as a JSON string
      string inline = 4;
    }
  }

  message TransformationPolicy {
    message Transform {
      repeated HeaderTransformation set = 1;
      repeated HeaderTransformation add = 2;
      repeated string remove = 3;
      BodyTransformation body = 4;
    }
    Transform request = 1;
    Transform response = 2;
  }

  message HeaderTransformation {
    string name = 1;
    string expression = 2;
  }

  message BodyTransformation {
    string expression = 1;
  }

  // Cross-Site Request Forgery (CSRF) policy configuration.
  message CSRF {
    // Additional origins that are allowed for CSRF validation beyond the same-origin policy.
    // If a request's origin header matches any of these exact origins, the request will be allowed.
    // Each origin should be in the format "scheme://host[:port]" (e.g., "https://www.example.com")
    repeated string additional_origins = 1;
  }

  message ExtProc {
    enum FailureMode{
      FAIL_CLOSED = 0;
      FAIL_OPEN = 1;
    }
    BackendReference target = 1;
    FailureMode failure_mode = 2;
  }

  oneof kind {
    LocalRateLimit local_rate_limit = 1;
    ExternalAuth ext_authz = 2;
    RBAC mcp_authorization = 3;
    JWT jwt = 4;
    TransformationPolicy transformation = 5;
    RemoteRateLimit remote_rate_limit = 6;
    CSRF csrf = 7;
    ExtProc ext_proc = 8;
    HeaderModifier request_header_modifier = 9;
    HeaderModifier response_header_modifier = 10;
    CORS cors = 11;
  }
}

message Policy {
  // Format is "<ns>/<name>"
  string name = 1;
  PolicyTarget target = 2;
  oneof kind {
    TrafficPolicySpec traffic = 3;
    BackendPolicySpec backend = 4;
    FrontendPolicySpec frontend = 5;
  }
}
message Backend {
  // Format is "<ns>/<name>"
  string name = 1;
  oneof kind {
    StaticBackend static = 2;
    AIBackend ai = 3;
    MCPBackend mcp = 4;
  }
}

message StaticBackend {
  string host = 1;
  int32 port = 2;
}

message AIBackend {
  message HostOverride {
    string host = 1;
    int32 port = 2;
  }
  message OpenAI {
    google.protobuf.StringValue model = 1;
  }
  message Gemini {
    google.protobuf.StringValue model = 1;
  }
  message Vertex {
    google.protobuf.StringValue model = 1;
    string region = 2;
    string project_id = 3;
  }
  message Anthropic {
    google.protobuf.StringValue model = 1;
  }
  message Bedrock {
    google.protobuf.StringValue model = 1;
    string region = 2;
    google.protobuf.StringValue guardrail_identifier = 3;
    google.protobuf.StringValue guardrail_version = 4;
  }
  // RouteType specifies how incoming requests should be processed
  // based on the URL path.
  enum RouteType {
    // Unspecified defaults to COMPLETIONS
    UNSPECIFIED = 0;
    // Processes OpenAI /v1/chat/completions format requests
    COMPLETIONS = 1;
    // Processes Anthropic /v1/messages format requests
    MESSAGES = 2;
    // Handles /v1/models endpoint (returns available models)
    MODELS = 3;
    // Sends requests to upstream as-is without LLM processing
    PASSTHROUGH = 4;
  }
  message Provider {
    string name = 1;
    HostOverride host_override = 2;
    google.protobuf.StringValue path_override = 3;
    oneof provider {
      OpenAI openai = 4;
      Gemini gemini = 5;
      Vertex vertex = 6;
      Anthropic anthropic = 7;
      Bedrock bedrock = 8;
    }
    // Routes defines how to identify the type of traffic to handle.
    // The keys are URL suffix matches (e.g., "/v1/chat/completions", "/v1/messages").
    // The special "*" wildcard matches any path.
    // If not specified, all traffic is treated as ROUTE_TYPE_COMPLETIONS.
    map<string, RouteType> routes = 9;
  }
  message ProviderGroup {
    repeated Provider providers = 1;
  }
  repeated ProviderGroup provider_groups = 1;
}

message MCPBackend {
  enum StatefulMode {
    STATEFUL = 0;
    STATELESS = 1;
  }

  enum PrefixMode {
    CONDITIONAL = 0;
    ALWAYS = 1;
  }

  repeated MCPTarget targets = 2;
  // Whether or not this backend should serve stateful MCP connections.
  // We set this at the backend level because it would be illegal/nonsensical
  // to mix stateful and stateless targets in the same backend.
  StatefulMode stateful_mode = 3;
  // Whether to always prefix the tool name using the target name
  PrefixMode prefix_mode = 4;
}

message MCPTarget {
  enum Protocol {
    UNDEFINED = 0;
    SSE = 1;
    STREAMABLE_HTTP = 2;
  }
  string name = 1;
  BackendReference backend = 2;
  string path = 3;
  Protocol protocol = 4;
}

message BackendReference {
  oneof kind {
    // A service (could be Service, ServiceEntry, etc) in "<ns>/<hostname>" format
    // These are joined with the service discovery.
    string service = 1;
    // A Backend object.
    // Format is "<ns>/<name>". Joined with the Backend object.
    // Must be of type StaticBackend.
    string backend = 2;
  }
  // Port, used only with 'service' type
  uint32 port = 3;
}
