use std::collections::BTreeMap;

use crate::Value;
use crate::common::value::CelVal;

pub mod operators;

pub struct Ast {
	pub expr: IdedExpr,
}

#[derive(Clone, Debug, Default, PartialEq)]
pub enum Expr {
	#[default]
	/// UnspecifiedExprKind represents an unset expression with no specified properties.
	Unspecified,

	/// CallKind represents a function call.
	Call(CallExpr),

	/// ComprehensionKind represents a comprehension expression generated by a macro.
	Comprehension(Box<ComprehensionExpr>),

	/// IdentKind represents a simple variable, constant, or type identifier.
	Ident(String),

	/// ListKind represents a list literal expression.
	List(ListExpr),

	/// LiteralKind represents a primitive scalar literal.
	Literal(CelVal),

	/// An inlined Value
	Inline(Value<'static>),

	/// MapKind represents a map literal expression.
	Map(MapExpr),

	/// SelectKind represents a field selection expression.
	Select(SelectExpr),

	/// StructKind represents a struct literal expression.
	Struct(StructExpr),
	/// An expression that has been optimized
	Optimized {
		original: Box<IdedExpr>,
		optimized: OptimizedExpr,
	},
}

#[derive(Clone, Debug, PartialEq)]
pub enum OptimizedExpr {
	HeaderLookup {
		// Request or response
		request: bool,
		header: http::HeaderName,
	},
}

impl Expr {
	pub fn type_name(&self) -> &'static str {
		match self {
			Expr::Unspecified => "unspecified",
			Expr::Call(_) => "call",
			Expr::Comprehension(_) => "comprehension",
			Expr::Ident(_) => "ident",
			Expr::List(_) => "list",
			Expr::Literal(_) => "literal",
			Expr::Inline(_) => "inline",
			Expr::Map(_) => "map",
			Expr::Select(_) => "select",
			Expr::Struct(_) => "struct",
			Expr::Optimized { original, .. } => original.expr.type_name(),
		}
	}
}

#[derive(Clone, Debug, PartialEq)]
pub enum EntryExpr {
	StructField(StructFieldExpr),
	MapEntry(MapEntryExpr),
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct IdedExpr {
	pub id: u64,
	pub expr: Expr,
}

#[derive(Clone, Debug, PartialEq)]
pub struct IdedEntryExpr {
	pub id: u64,
	pub expr: EntryExpr,
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct CallExpr {
	pub func_name: String,
	pub target: Option<Box<IdedExpr>>,
	pub args: Vec<IdedExpr>,
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct SelectExpr {
	pub operand: Box<IdedExpr>,
	pub field: String,
	pub test: bool,
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct StructExpr {
	pub type_name: String,
	pub entries: Vec<IdedEntryExpr>,
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct MapExpr {
	pub entries: Vec<IdedEntryExpr>,
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct ListExpr {
	pub elements: Vec<IdedExpr>,
	pub optional_indices: Vec<usize>,
}

impl ListExpr {
	pub fn new(elements: Vec<IdedExpr>) -> Self {
		Self::new_with_optionals(elements, Vec::default())
	}

	pub fn new_with_optionals(elements: Vec<IdedExpr>, optional_indices: Vec<usize>) -> Self {
		Self {
			elements,
			optional_indices,
		}
	}
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct StructFieldExpr {
	pub field: String,
	pub value: IdedExpr,
	pub optional: bool,
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct MapEntryExpr {
	pub key: IdedExpr,
	pub value: IdedExpr,
	pub optional: bool,
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct ComprehensionExpr {
	pub iter_range: IdedExpr,
	pub iter_var: String,
	pub iter_var2: Option<String>,
	pub accu_var: String,
	pub accu_init: IdedExpr,
	pub loop_cond: IdedExpr,
	pub loop_step: IdedExpr,
	pub result: IdedExpr,
}

#[derive(Debug, Default)]
pub struct SourceInfo {
	offsets: BTreeMap<u64, OffsetRange>,
	pub source: String,
}

impl SourceInfo {
	pub fn add_offset(&mut self, id: u64, start: u32, stop: u32) {
		self.offsets.insert(id, OffsetRange { start, stop });
	}

	pub fn offset_for(&self, id: u64) -> Option<(u32, u32)> {
		self.offsets.get(&id).map(|range| (range.start, range.stop))
	}

	pub(crate) fn pos_for(&self, id: u64) -> Option<(isize, isize)> {
		match self.offset_for(id) {
			Some((start, _)) => {
				let start = start as isize;
				let mut offset = 0;
				let mut line = 0;
				for l in self.source.split_inclusive('\n') {
					line += 1;
					offset += l.len() as isize;
					if start < offset {
						return Some((line, start + (l.len() as isize) - offset + 1));
					}
				}
				None
			},
			None => None,
		}
	}

	pub fn snippet(&self, line: isize) -> Option<&str> {
		self.source.lines().nth(line as usize)
	}
}

#[derive(Clone, Debug, Default, PartialEq)]
pub struct OffsetRange {
	pub start: u32,
	pub stop: u32,
}
